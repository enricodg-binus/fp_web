{"remainingRequest":"/Users/enrico/code/angular/fp_web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/enrico/code/angular/fp_web/node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js","dependencies":[{"path":"/Users/enrico/code/angular/fp_web/node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js","mtime":499162500000},{"path":"/Users/enrico/code/angular/fp_web/node_modules/cache-loader/dist/cjs.js","mtime":1522355410796},{"path":"/Users/enrico/code/angular/fp_web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1522355408304}],"contextDependencies":[],"result":["import noop from 'lodash/noop';\nimport { checkRendering, parseAroundLatLngFromString } from '../../lib/utils';\n\nvar usage = 'Usage:\\n\\nvar customGeoSearch = connectGeoSearch(function render(params, isFirstRendering) {\\n  // params = {\\n  //   items,\\n  //   position,\\n  //   refine,\\n  //   clearMapRefinement,\\n  //   isRefinedWithMap,\\n  //   toggleRefineOnMapMove,\\n  //   isRefineOnMapMove,\\n  //   setMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   widgetParams,\\n  //   instantSearchInstance,\\n  // }\\n});\\n\\nsearch.addWidget(\\n  customGeoSearch({\\n    [ enableRefineOnMapMove = true ],\\n    [ enableGeolocationWithIP = true ],\\n    [ position ],\\n    [ radius ],\\n    [ precision ],\\n  })\\n);\\n\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectGeoSearch.html\\n';\n\n/**\n * @typedef {Object} LatLng\n * @property {number} lat The latitude in degrees.\n * @property {number} lng The longitude in degrees.\n */\n\n/**\n * @typedef {Object} Bounds\n * @property {LatLng} northEast The top right corner of the map view.\n * @property {LatLng} southWest The bottom left corner of the map view.\n */\n\n/**\n * @typedef {Object} CustomGeoSearchWidgetOptions\n * @property {boolean} [enableRefineOnMapMove=true] If true, refine will be triggered as you move the map.\n * @property {boolean} [enableGeolocationWithIP=true] If true, the IP will be use for the geolocation. When the `position` option is provided this option will be ignored. See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLngViaIP) for more informations.\n * @property {LatLng} [position] Position that will be use to search around. <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLng) for more informations.\n * @property {number} [radius] Maximum radius to search around the position (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundRadius) for more informations.\n * @property {number} [precision] Precision of geo search (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundPrecision) for more informations.\n */\n\n/**\n * @typedef {Object} GeoSearchRenderingOptions\n * @property {Object[]} items The matched hits from Algolia API.\n * @property {function(Bounds)} refine Sets a bounding box to filter the results from the given map bounds.\n * @property {function()} clearMapRefinement Reset the current bounding box refinement.\n * @property {function(): boolean} isRefinedWithMap Return true if the current refinement is set with the map bounds.\n * @property {function()} toggleRefineOnMapMove Toggle the fact that the user is able to refine on map move.\n * @property {function(): boolean} isRefineOnMapMove Return true if the user is able to refine on map move.\n * @property {function()} setMapMoveSinceLastRefine Set the fact that the map has moved since the last refinement, should be call on each map move. The call to the function triggers a new rendering only when the value change.\n * @property {function(): boolean} hasMapMoveSinceLastRefine Return true if the map has move since the last refinement.\n * @property {Object} widgetParams All original `CustomGeoSearchWidgetOptions` forwarded to the `renderFn`.\n * @property {LatLng} [position] The current position of the search.\n */\n\n/**\n * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).\n *\n * @requirements\n *\n * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.\n *\n * Currently, the feature is not compatible with multiple values in the _geoloc attribute.\n *\n * @type {Connector}\n * @param {function(GeoSearchRenderingOptions, boolean)} renderFn Rendering function for the custom **GeoSearch** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomGeoSearchWidgetOptions)} Re-usable widget factory for a custom **GeoSearch** widget.\n * @staticExample\n * // This example use Leaflet for the rendering, be sure to have the library correctly setup\n * // before trying the demo. You can find more details in their documentation (link below).\n * // We choose Leaflet for the example but you can use any libraries that you want.\n * // See: http://leafletjs.com/examples/quick-start\n *\n * let map = null;\n * let markers = [];\n *\n * // custom `renderFn` to render the custom GeoSearch widget\n * function renderFn(GeoSearchRenderingOptions, isFirstRendering) {\n *   const { items, widgetParams } = GeoSearchRenderingOptions;\n *\n *   if (isFirstRendering) {\n *     map = L.map(widgetParams.container);\n *\n *     L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n *       attribution:\n *         '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors',\n *     }).addTo(map);\n *   }\n *\n *   markers.forEach(marker => marker.remove());\n *\n *   markers = items.map(({ _geoloc }) =>\n *     L.marker([_geoloc.lat, _geoloc.lng]).addTo(map)\n *   );\n *\n *   if (markers.length) {\n *     map.fitBounds(L.featureGroup(markers).getBounds());\n *   }\n * }\n *\n * // connect `renderFn` to GeoSearch logic\n * const customGeoSearch = instantsearch.connectors.connectGeoSearch(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customGeoSearch({\n *     container: document.getElementById('custom-geo-search'),\n *   })\n * );\n */\nvar connectGeoSearch = function connectGeoSearch(renderFn, unmountFn) {\n  checkRendering(renderFn, usage);\n\n  return function () {\n    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _widgetParams$enableR = widgetParams.enableRefineOnMapMove,\n        enableRefineOnMapMove = _widgetParams$enableR === undefined ? true : _widgetParams$enableR,\n        _widgetParams$enableG = widgetParams.enableGeolocationWithIP,\n        enableGeolocationWithIP = _widgetParams$enableG === undefined ? true : _widgetParams$enableG,\n        position = widgetParams.position,\n        radius = widgetParams.radius,\n        precision = widgetParams.precision;\n\n\n    var widgetState = {\n      isRefineOnMapMove: enableRefineOnMapMove,\n      hasMapMoveSinceLastRefine: false,\n      lastRefinePosition: '',\n      lastRefineBoundingBox: '',\n      internalToggleRefineOnMapMove: noop,\n      internalSetMapMoveSinceLastRefine: noop\n    };\n\n    var getPositionFromState = function getPositionFromState(state) {\n      return state.aroundLatLng && parseAroundLatLngFromString(state.aroundLatLng);\n    };\n\n    var refine = function refine(helper) {\n      return function (_ref) {\n        var ne = _ref.northEast,\n            sw = _ref.southWest;\n\n        var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();\n\n        helper.setQueryParameter('insideBoundingBox', boundingBox).search();\n\n        widgetState.hasMapMoveSinceLastRefine = false;\n        widgetState.lastRefineBoundingBox = boundingBox;\n      };\n    };\n\n    var clearMapRefinement = function clearMapRefinement(helper) {\n      return function () {\n        helper.setQueryParameter('insideBoundingBox').search();\n      };\n    };\n\n    var isRefinedWithMap = function isRefinedWithMap(state) {\n      return function () {\n        return Boolean(state.insideBoundingBox);\n      };\n    };\n\n    var toggleRefineOnMapMove = function toggleRefineOnMapMove() {\n      return widgetState.internalToggleRefineOnMapMove();\n    };\n    var createInternalToggleRefinementonMapMove = function createInternalToggleRefinementonMapMove(render, args) {\n      return function () {\n        widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;\n\n        render(args);\n      };\n    };\n\n    var isRefineOnMapMove = function isRefineOnMapMove() {\n      return widgetState.isRefineOnMapMove;\n    };\n\n    var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {\n      return widgetState.internalSetMapMoveSinceLastRefine();\n    };\n    var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(render, args) {\n      return function () {\n        var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;\n\n        widgetState.hasMapMoveSinceLastRefine = true;\n\n        if (shouldTriggerRender) {\n          render(args);\n        }\n      };\n    };\n\n    var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {\n      return widgetState.hasMapMoveSinceLastRefine;\n    };\n\n    var init = function init(initArgs) {\n      var state = initArgs.state,\n          helper = initArgs.helper,\n          instantSearchInstance = initArgs.instantSearchInstance;\n\n      var isFirstRendering = true;\n\n      widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(noop, initArgs);\n\n      widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(noop, initArgs);\n\n      renderFn({\n        items: [],\n        position: getPositionFromState(state),\n        refine: refine(helper),\n        clearMapRefinement: clearMapRefinement(helper),\n        isRefinedWithMap: isRefinedWithMap(state),\n        toggleRefineOnMapMove: toggleRefineOnMapMove,\n        isRefineOnMapMove: isRefineOnMapMove,\n        setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n        hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n        widgetParams: widgetParams,\n        instantSearchInstance: instantSearchInstance\n      }, isFirstRendering);\n    };\n\n    var render = function render(renderArgs) {\n      var results = renderArgs.results,\n          helper = renderArgs.helper,\n          instantSearchInstance = renderArgs.instantSearchInstance;\n\n      var isFirstRendering = false;\n      // We don't use the state provided by the render function because we need\n      // to be sure that the state is the latest one for the following condition\n      var state = helper.getState();\n\n      var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;\n\n      var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;\n\n      if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {\n        widgetState.hasMapMoveSinceLastRefine = false;\n      }\n\n      widgetState.lastRefinePosition = state.aroundLatLng || '';\n      widgetState.lastRefineBoundingBox = state.insideBoundingBox || '';\n\n      widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(render, renderArgs);\n\n      widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(render, renderArgs);\n\n      renderFn({\n        items: results.hits.filter(function (hit) {\n          return hit._geoloc;\n        }),\n        position: getPositionFromState(state),\n        refine: refine(helper),\n        clearMapRefinement: clearMapRefinement(helper),\n        isRefinedWithMap: isRefinedWithMap(state),\n        toggleRefineOnMapMove: toggleRefineOnMapMove,\n        isRefineOnMapMove: isRefineOnMapMove,\n        setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n        hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n        widgetParams: widgetParams,\n        instantSearchInstance: instantSearchInstance\n      }, isFirstRendering);\n    };\n\n    return {\n      init: init,\n      render: render,\n\n      getConfiguration: function getConfiguration(previous) {\n        var configuration = {};\n\n        if (enableGeolocationWithIP && !position && !previous.aroundLatLng && previous.aroundLatLngViaIP === undefined) {\n          configuration.aroundLatLngViaIP = true;\n        }\n\n        if (position && !previous.aroundLatLng && !previous.aroundLatLngViaIP) {\n          configuration.aroundLatLng = position.lat + ', ' + position.lng;\n        }\n\n        if (radius && !previous.aroundRadius) {\n          configuration.aroundRadius = radius;\n        }\n\n        if (precision && !previous.aroundPrecision) {\n          configuration.aroundPrecision = precision;\n        }\n\n        return configuration;\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n\n        unmountFn();\n\n        var nextState = state;\n\n        if (enableGeolocationWithIP && !position) {\n          nextState = nextState.setQueryParameter('aroundLatLngViaIP');\n        }\n\n        if (position) {\n          nextState = nextState.setQueryParameter('aroundLatLng');\n        }\n\n        if (radius) {\n          nextState = nextState.setQueryParameter('aroundRadius');\n        }\n\n        if (precision) {\n          nextState = nextState.setQueryParameter('aroundPrecision');\n        }\n\n        nextState = nextState.setQueryParameter('insideBoundingBox');\n\n        return nextState;\n      }\n    };\n  };\n};\n\nexport default connectGeoSearch;",null]}