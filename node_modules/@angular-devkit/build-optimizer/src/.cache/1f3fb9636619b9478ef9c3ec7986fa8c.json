{"remainingRequest":"/Users/enrico/code/angular/fp_web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/enrico/code/angular/fp_web/node_modules/instantsearch.js/es/lib/InstantSearch.js","dependencies":[{"path":"/Users/enrico/code/angular/fp_web/node_modules/instantsearch.js/es/lib/InstantSearch.js","mtime":499162500000},{"path":"/Users/enrico/code/angular/fp_web/node_modules/cache-loader/dist/cjs.js","mtime":1522355410796},{"path":"/Users/enrico/code/angular/fp_web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1522355408304}],"contextDependencies":[],"result":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// we use the full path to the lite build to solve a meteor.js issue:\n// https://github.com/algolia/instantsearch.js/issues/1024#issuecomment-221618284\nimport algoliasearch from 'algoliasearch/src/browser/builds/algoliasearchLite.js';\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport forEach from 'lodash/forEach';\nimport mergeWith from 'lodash/mergeWith';\nimport union from 'lodash/union';\nimport isPlainObject from 'lodash/isPlainObject';\nimport EventEmitter from 'events';\nimport urlSyncWidget from './url-sync.js';\nimport version from './version.js';\nimport createHelpers from './createHelpers.js';\n\nfunction defaultCreateURL() {\n  return '#';\n}\nvar defaultCreateAlgoliaClient = function defaultCreateAlgoliaClient(defaultAlgoliasearch, appId, apiKey) {\n  return defaultAlgoliasearch(appId, apiKey);\n};\n\n/**\n * Widgets are the building blocks of InstantSearch.js. Any\n * valid widget must have at least a `render` or a `init` function.\n * @typedef {Object} Widget\n * @property {function} [render] Called after each search response has been received\n * @property {function} [getConfiguration] Let the widget update the configuration\n * of the search with new parameters\n * @property {function} [init] Called once before the first search\n */\n\n/**\n * The actual implementation of the InstantSearch. This is\n * created using the `instantsearch` factory function.\n * @fires Instantsearch#render This event is triggered each time a render is done\n */\n\nvar InstantSearch = function (_EventEmitter) {\n  _inherits(InstantSearch, _EventEmitter);\n\n  function InstantSearch(_ref) {\n    var _ref$appId = _ref.appId,\n        appId = _ref$appId === undefined ? null : _ref$appId,\n        _ref$apiKey = _ref.apiKey,\n        apiKey = _ref$apiKey === undefined ? null : _ref$apiKey,\n        _ref$indexName = _ref.indexName,\n        indexName = _ref$indexName === undefined ? null : _ref$indexName,\n        numberLocale = _ref.numberLocale,\n        _ref$searchParameters = _ref.searchParameters,\n        searchParameters = _ref$searchParameters === undefined ? {} : _ref$searchParameters,\n        _ref$urlSync = _ref.urlSync,\n        urlSync = _ref$urlSync === undefined ? null : _ref$urlSync,\n        searchFunction = _ref.searchFunction,\n        _ref$createAlgoliaCli = _ref.createAlgoliaClient,\n        createAlgoliaClient = _ref$createAlgoliaCli === undefined ? defaultCreateAlgoliaClient : _ref$createAlgoliaCli,\n        _ref$stalledSearchDel = _ref.stalledSearchDelay,\n        stalledSearchDelay = _ref$stalledSearchDel === undefined ? 200 : _ref$stalledSearchDel;\n\n    _classCallCheck(this, InstantSearch);\n\n    var _this = _possibleConstructorReturn(this, (InstantSearch.__proto__ || Object.getPrototypeOf(InstantSearch)).call(this));\n\n    if (appId === null || apiKey === null || indexName === null) {\n      var usage = '\\nUsage: instantsearch({\\n  appId: \\'my_application_id\\',\\n  apiKey: \\'my_search_api_key\\',\\n  indexName: \\'my_index_name\\'\\n});';\n      throw new Error(usage);\n    }\n\n    var client = createAlgoliaClient(algoliasearch, appId, apiKey);\n    client.addAlgoliaAgent('instantsearch.js ' + version);\n\n    _this.client = client;\n    _this.helper = null;\n    _this.indexName = indexName;\n    _this.searchParameters = _extends({}, searchParameters, { index: indexName });\n    _this.widgets = [];\n    _this.templatesConfig = {\n      helpers: createHelpers({ numberLocale: numberLocale }),\n      compileOptions: {}\n    };\n    _this._stalledSearchDelay = stalledSearchDelay;\n\n    if (searchFunction) {\n      _this._searchFunction = searchFunction;\n    }\n\n    _this.urlSync = urlSync === true ? {} : urlSync;\n    return _this;\n  }\n\n  /**\n   * Add a widget. This can be done before and after InstantSearch has been started. Adding a\n   * widget after InstantSearch started is considered **EXPERIMENTAL** and therefore\n   * it is possibly buggy, if you find anything please\n   * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20hot%20addWidget).\n   * @param  {Widget} widget The widget to add to InstantSearch. Widgets are simple objects\n   * that have methods that map the search life cycle in a UI perspective. Usually widgets are\n   * created by [widget factories](widgets.html) like the one provided with InstantSearch.js.\n   * @return {undefined} This method does not return anything\n   */\n\n\n  _createClass(InstantSearch, [{\n    key: 'addWidget',\n    value: function addWidget(widget) {\n      this.addWidgets([widget]);\n    }\n\n    /**\n     * Add multiple widgets. This can be done before and after the InstantSearch has been started. This feature\n     * is considered **EXPERIMENTAL** and therefore it is possibly buggy, if you find anything please\n     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20addWidgets).\n     * @param  {Widget[]} widgets The array of widgets to add to InstantSearch.\n     * @return {undefined} This method does not return anything\n     */\n\n  }, {\n    key: 'addWidgets',\n    value: function addWidgets(widgets) {\n      var _this2 = this;\n\n      if (!Array.isArray(widgets)) {\n        throw new Error('You need to provide an array of widgets or call `addWidget()`');\n      }\n\n      widgets.forEach(function (widget) {\n        // Add the widget to the list of widget\n        if (widget.render === undefined && widget.init === undefined) {\n          throw new Error('Widget definition missing render or init method');\n        }\n\n        _this2.widgets.push(widget);\n      });\n\n      // Init the widget directly if instantsearch has been already started\n      if (this.started) {\n        this.searchParameters = this.widgets.reduce(enhanceConfiguration({}), _extends({}, this.helper.state));\n\n        this.helper.setState(this.searchParameters);\n\n        widgets.forEach(function (widget) {\n          if (widget.init) {\n            widget.init({\n              state: _this2.helper.state,\n              helper: _this2.helper,\n              templatesConfig: _this2.templatesConfig,\n              createURL: _this2._createAbsoluteURL,\n              onHistoryChange: _this2._onHistoryChange,\n              instantSearchInstance: _this2\n            });\n          }\n        });\n\n        this.helper.search();\n      }\n    }\n\n    /**\n     * Removes a widget. This can be done after the InstantSearch has been started. This feature\n     * is considered **EXPERIMENTAL** and therefore it is possibly buggy, if you find anything please\n     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20removeWidget).\n     * @param  {Widget} widget The widget instance to remove from InstantSearch. This widget must implement a `dispose()` method in order to be gracefully removed.\n     * @return {undefined} This method does not return anything\n     */\n\n  }, {\n    key: 'removeWidget',\n    value: function removeWidget(widget) {\n      this.removeWidgets([widget]);\n    }\n\n    /**\n     * Remove multiple widgets. This can be done only after the InstantSearch has been started. This feature\n     * is considered **EXPERIMENTAL** and therefore it is possibly buggy, if you find anything please\n     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20addWidgets).\n     * @param  {Widget[]} widgets Array of widgets instances to remove from InstantSearch.\n     * @return {undefined} This method does not return anything\n     */\n\n  }, {\n    key: 'removeWidgets',\n    value: function removeWidgets(widgets) {\n      var _this3 = this;\n\n      if (!Array.isArray(widgets)) {\n        throw new Error('You need to provide an array of widgets or call `removeWidget()`');\n      }\n\n      widgets.forEach(function (widget) {\n        if (!_this3.widgets.includes(widget) || typeof widget.dispose !== 'function') {\n          throw new Error('The widget you tried to remove does not implement the dispose method, therefore it is not possible to remove this widget');\n        }\n\n        _this3.widgets = _this3.widgets.filter(function (w) {\n          return w !== widget;\n        });\n\n        var nextState = widget.dispose({\n          helper: _this3.helper,\n          state: _this3.helper.getState()\n        });\n\n        // re-compute remaining widgets to the state\n        // in a case two widgets were using the same configuration but we removed one\n        if (nextState) {\n          // We don't want to re-add URlSync `getConfiguration` widget\n          // it can throw errors since it may re-add SearchParameters about something unmounted\n          _this3.searchParameters = _this3.widgets.filter(function (w) {\n            return w.constructor.name !== 'URLSync';\n          }).reduce(enhanceConfiguration({}), _extends({}, nextState));\n\n          _this3.helper.setState(_this3.searchParameters);\n        }\n      });\n\n      // no need to trigger a search if we don't have any widgets left\n      if (this.widgets.length > 0) {\n        this.helper.search();\n      }\n    }\n\n    /**\n     * The refresh method clears the cached answers from Algolia and triggers a new search.\n     *\n     * @return {undefined} Does not return anything\n     */\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      if (this.helper) {\n        this.helper.clearCache().search();\n      }\n    }\n\n    /**\n     * The start method ends the initialization of InstantSearch.js and triggers the\n     * first search. This method should be called after all widgets have been added\n     * to the instance of InstantSearch.js. InstantSearch.js also supports adding and removing\n     * widgets after the start as an **EXPERIMENTAL** feature.\n     *\n     * @return {undefined} Does not return anything\n     */\n\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this4 = this;\n\n      if (!this.widgets) throw new Error('No widgets were added to instantsearch.js');\n\n      if (this.started) throw new Error('start() has been already called once');\n\n      var searchParametersFromUrl = void 0;\n\n      if (this.urlSync) {\n        var syncWidget = urlSyncWidget(this.urlSync);\n        this._createURL = syncWidget.createURL.bind(syncWidget);\n        this._createAbsoluteURL = function (relative) {\n          return _this4._createURL(relative, { absolute: true });\n        };\n        this._onHistoryChange = syncWidget.onHistoryChange.bind(syncWidget);\n        this.widgets.push(syncWidget);\n        searchParametersFromUrl = syncWidget.searchParametersFromUrl;\n      } else {\n        this._createURL = defaultCreateURL;\n        this._createAbsoluteURL = defaultCreateURL;\n        this._onHistoryChange = function () {};\n      }\n\n      this.searchParameters = this.widgets.reduce(enhanceConfiguration(searchParametersFromUrl), this.searchParameters);\n\n      var helper = algoliasearchHelper(this.client, this.searchParameters.index || this.indexName, this.searchParameters);\n\n      if (this._searchFunction) {\n        this._mainHelperSearch = helper.search.bind(helper);\n        helper.search = function () {\n          var helperSearchFunction = algoliasearchHelper({\n            addAlgoliaAgent: function addAlgoliaAgent() {},\n            search: function search() {}\n          }, helper.state.index, helper.state);\n          helperSearchFunction.once('search', function (state) {\n            helper.overrideStateWithoutTriggeringChangeEvent(state);\n            _this4._mainHelperSearch();\n          });\n          _this4._searchFunction(helperSearchFunction);\n        };\n      }\n\n      this.helper = helper;\n      this._init(helper.state, this.helper);\n      this.helper.on('result', this._render.bind(this, this.helper));\n      this.helper.on('error', function (e) {\n        _this4.emit('error', e);\n      });\n\n      this._searchStalledTimer = null;\n      this._isSearchStalled = true;\n\n      this.helper.search();\n\n      this.helper.on('search', function () {\n        if (!_this4._isSearchStalled && !_this4._searchStalledTimer) {\n          _this4._searchStalledTimer = setTimeout(function () {\n            _this4._isSearchStalled = true;\n            _this4._render(_this4.helper, _this4.helper.lastResults, _this4.helper.lastResults._state);\n          }, _this4._stalledSearchDelay);\n        }\n      });\n\n      // track we started the search if we add more widgets,\n      // to init them directly after add\n      this.started = true;\n    }\n\n    /**\n     * Remove all widgets without triggering a search afterwards. This is an **EXPERIMENTAL** feature,\n     * if you find an issue with it, please\n     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20dispose).\n     * @return {undefined} This method does not return anything\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.removeWidgets(this.widgets);\n    }\n  }, {\n    key: 'createURL',\n    value: function createURL(params) {\n      if (!this._createURL) {\n        throw new Error('You need to call start() before calling createURL()');\n      }\n      return this._createURL(this.helper.state.setQueryParameters(params));\n    }\n  }, {\n    key: '_render',\n    value: function _render(helper, results, state) {\n      var _this5 = this;\n\n      if (!this.helper.hasPendingRequests()) {\n        clearTimeout(this._searchStalledTimer);\n        this._searchStalledTimer = null;\n        this._isSearchStalled = false;\n      }\n\n      forEach(this.widgets, function (widget) {\n        if (!widget.render) {\n          return;\n        }\n        widget.render({\n          templatesConfig: _this5.templatesConfig,\n          results: results,\n          state: state,\n          helper: helper,\n          createURL: _this5._createAbsoluteURL,\n          instantSearchInstance: _this5,\n          searchMetadata: {\n            isSearchStalled: _this5._isSearchStalled\n          }\n        });\n      });\n\n      /**\n       * Render is triggered when the rendering of the widgets has been completed\n       * after a search.\n       * @event InstantSearch#render\n       */\n      this.emit('render');\n    }\n  }, {\n    key: '_init',\n    value: function _init(state, helper) {\n      var _this6 = this;\n\n      forEach(this.widgets, function (widget) {\n        if (widget.init) {\n          widget.init({\n            state: state,\n            helper: helper,\n            templatesConfig: _this6.templatesConfig,\n            createURL: _this6._createAbsoluteURL,\n            onHistoryChange: _this6._onHistoryChange,\n            instantSearchInstance: _this6\n          });\n        }\n      });\n    }\n  }]);\n\n  return InstantSearch;\n}(EventEmitter);\n\nfunction enhanceConfiguration(searchParametersFromUrl) {\n  return function (configuration, widgetDefinition) {\n    if (!widgetDefinition.getConfiguration) return configuration;\n\n    // Get the relevant partial configuration asked by the widget\n    var partialConfiguration = widgetDefinition.getConfiguration(configuration, searchParametersFromUrl);\n\n    var customizer = function customizer(a, b) {\n      // always create a unified array for facets refinements\n      if (Array.isArray(a)) {\n        return union(a, b);\n      }\n\n      // avoid mutating objects\n      if (isPlainObject(a)) {\n        return mergeWith({}, a, b, customizer);\n      }\n\n      return undefined;\n    };\n\n    return mergeWith({}, configuration, partialConfiguration, customizer);\n  };\n}\n\nexport default InstantSearch;",null]}