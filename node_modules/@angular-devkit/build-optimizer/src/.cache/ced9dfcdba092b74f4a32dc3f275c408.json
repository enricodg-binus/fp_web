{"remainingRequest":"/Users/enrico/code/angular/fp_web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/enrico/code/angular/fp_web/node_modules/instantsearch.js/es/lib/utils.js","dependencies":[{"path":"/Users/enrico/code/angular/fp_web/node_modules/instantsearch.js/es/lib/utils.js","mtime":499162500000},{"path":"/Users/enrico/code/angular/fp_web/node_modules/cache-loader/dist/cjs.js","mtime":1522355410796},{"path":"/Users/enrico/code/angular/fp_web/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1522355408304}],"contextDependencies":[],"result":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport reduce from 'lodash/reduce';\nimport forEach from 'lodash/forEach';\nimport find from 'lodash/find';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport keys from 'lodash/keys';\nimport uniq from 'lodash/uniq';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport curry from 'lodash/curry';\nimport hogan from 'hogan.js';\n\nexport { getContainerNode, bemHelper, prepareTemplateProps, renderTemplate, isSpecialClick, isDomElement, getRefinements, clearRefinementsFromState, clearRefinementsAndSearch, prefixKeys, escapeRefinement, unescapeRefinement, checkRendering, isReactElement, deprecate, parseAroundLatLngFromString };\n\n/**\n * Return the container. If it's a string, it is considered a\n * css selector and retrieves the first matching element. Otherwise\n * test if it validates that it's a correct DOMElement.\n * @param {string|HTMLElement} selectorOrHTMLElement a selector or a node\n * @return {HTMLElement} The resolved HTMLElement\n * @throws Error when the type is not correct\n */\nfunction getContainerNode(selectorOrHTMLElement) {\n  var isFromString = typeof selectorOrHTMLElement === 'string';\n  var domElement = void 0;\n  if (isFromString) {\n    domElement = document.querySelector(selectorOrHTMLElement);\n  } else {\n    domElement = selectorOrHTMLElement;\n  }\n\n  if (!isDomElement(domElement)) {\n    var errorMessage = 'Container must be `string` or `HTMLElement`.';\n    if (isFromString) {\n      errorMessage += ' Unable to find ' + selectorOrHTMLElement;\n    }\n    throw new Error(errorMessage);\n  }\n\n  return domElement;\n}\n\n/**\n * Returns true if the parameter is a DOMElement.\n * @param {any} o the value to test\n * @return {boolean} true if o is a DOMElement\n */\nfunction isDomElement(o) {\n  return o instanceof window.HTMLElement || Boolean(o) && o.nodeType > 0;\n}\n\nfunction isSpecialClick(event) {\n  var isMiddleClick = event.button === 1;\n  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n}\n\n/**\n * Creates BEM class name according the vanilla BEM style.\n * @param {string} block the main block\n * @return {function} function that takes up to 2 parameters\n * that determine the element and the modifier of the BEM class.\n */\nfunction bemHelper(block) {\n  return function (element, modifier) {\n    // block--element\n    if (element && !modifier) {\n      return block + '--' + element;\n    }\n    // block--element__modifier\n    if (element && modifier) {\n      return block + '--' + element + '__' + modifier;\n    }\n    // block__modifier\n    if (!element && modifier) {\n      return block + '__' + modifier;\n    }\n\n    return block;\n  };\n}\n\n/**\n * Prepares an object to be passed to the Template widget\n * @param {object} unknownBecauseES6 an object with the following attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - templatesConfig\n * @return {object} the configuration with the attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - useCustomCompileOptions\n */\nfunction prepareTemplateProps(_ref) {\n  var transformData = _ref.transformData,\n      defaultTemplates = _ref.defaultTemplates,\n      templates = _ref.templates,\n      templatesConfig = _ref.templatesConfig;\n\n  var preparedTemplates = prepareTemplates(defaultTemplates, templates);\n\n  return _extends({\n    transformData: transformData,\n    templatesConfig: templatesConfig\n  }, preparedTemplates);\n}\n\nfunction prepareTemplates() {\n  var defaultTemplates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var allKeys = uniq([].concat(_toConsumableArray(keys(defaultTemplates)), _toConsumableArray(keys(templates))));\n\n  return reduce(allKeys, function (config, key) {\n    var defaultTemplate = defaultTemplates[key];\n    var customTemplate = templates[key];\n    var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;\n\n    config.templates[key] = isCustomTemplate ? customTemplate : defaultTemplate;\n    config.useCustomCompileOptions[key] = isCustomTemplate;\n\n    return config;\n  }, { templates: {}, useCustomCompileOptions: {} });\n}\n\nfunction renderTemplate(_ref2) {\n  var templates = _ref2.templates,\n      templateKey = _ref2.templateKey,\n      compileOptions = _ref2.compileOptions,\n      helpers = _ref2.helpers,\n      data = _ref2.data;\n\n  var template = templates[templateKey];\n  var templateType = typeof template === 'undefined' ? 'undefined' : _typeof(template);\n  var isTemplateString = templateType === 'string';\n  var isTemplateFunction = templateType === 'function';\n\n  if (!isTemplateString && !isTemplateFunction) {\n    throw new Error('Template must be \\'string\\' or \\'function\\', was \\'' + templateType + '\\' (key: ' + templateKey + ')');\n  }\n\n  if (isTemplateFunction) {\n    return template(data);\n  }\n\n  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);\n\n  return hogan.compile(template, compileOptions).render(_extends({}, data, {\n    helpers: transformedHelpers\n  }));\n}\n\n// We add all our template helper methods to the template as lambdas. Note\n// that lambdas in Mustache are supposed to accept a second argument of\n// `render` to get the rendered value, not the literal `{{value}}`. But\n// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).\nfunction transformHelpersToHogan(helpers, compileOptions, data) {\n  return mapValues(helpers, function (method) {\n    return curry(function (text) {\n      var _this = this;\n\n      var render = function render(value) {\n        return hogan.compile(value, compileOptions).render(_this);\n      };\n      return method.call(data, text, render);\n    });\n  });\n}\n\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var res = { type: type, attributeName: attributeName, name: name };\n  var facet = find(resultsFacets, { name: attributeName });\n  var count = void 0;\n  if (type === 'hierarchical') {\n    var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n    var split = name.split(facetDeclaration.separator);\n    res.name = split[split.length - 1];\n    for (var i = 0; facet !== undefined && i < split.length; ++i) {\n      facet = find(facet.data, { name: split[i] });\n    }\n    count = get(facet, 'count');\n  } else {\n    count = get(facet, 'data[\"' + res.name + '\"]');\n  }\n  var exhaustive = get(facet, 'exhaustive');\n  if (count !== undefined) {\n    res.count = count;\n  }\n  if (exhaustive !== undefined) {\n    res.exhaustive = exhaustive;\n  }\n  return res;\n}\n\nfunction getRefinements(results, state, clearsQuery) {\n  var res = clearsQuery && state.query && state.query.trim() ? [{\n    type: 'query',\n    name: state.query,\n    query: state.query\n  }] : [];\n\n  forEach(state.facetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n\n  forEach(state.facetsExcludes, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push({ type: 'exclude', attributeName: attributeName, name: name, exclude: true });\n    });\n  });\n\n  forEach(state.disjunctiveFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName,\n      // we unescapeRefinement any disjunctive refined value since they can be escaped\n      // when negative numeric values search `escapeRefinement` usage in code\n      unescapeRefinement(name), results.disjunctiveFacets));\n    });\n  });\n\n  forEach(state.hierarchicalFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'hierarchical', attributeName, name, results.hierarchicalFacets));\n    });\n  });\n\n  forEach(state.numericRefinements, function (operators, attributeName) {\n    forEach(operators, function (values, operator) {\n      forEach(values, function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: '' + value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n\n  forEach(state.tagRefinements, function (name) {\n    res.push({ type: 'tag', attributeName: '_tags', name: name });\n  });\n\n  return res;\n}\n\nfunction clearRefinementsFromState(inputState, attributeNames) {\n  var clearsQuery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var state = inputState;\n\n  if (clearsQuery) {\n    state = state.setQuery('');\n  }\n\n  if (isEmpty(attributeNames)) {\n    state = state.clearTags();\n    state = state.clearRefinements();\n    return state;\n  }\n\n  forEach(attributeNames, function (attributeName) {\n    if (attributeName === '_tags') {\n      state = state.clearTags();\n    } else {\n      state = state.clearRefinements(attributeName);\n    }\n  });\n\n  return state;\n}\n\nfunction clearRefinementsAndSearch(helper, attributeNames) {\n  var clearsQuery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  helper.setState(clearRefinementsFromState(helper.state, attributeNames, clearsQuery)).search();\n}\n\nfunction prefixKeys(prefix, obj) {\n  if (obj) {\n    return mapKeys(obj, function (v, k) {\n      return prefix + k;\n    });\n  }\n\n  return undefined;\n}\n\nfunction escapeRefinement(value) {\n  if (typeof value === 'number' && value < 0) {\n    value = String(value).replace(/^-/, '\\\\-');\n  }\n\n  return value;\n}\n\nfunction unescapeRefinement(value) {\n  return String(value).replace(/^\\\\-/, '-');\n}\n\nfunction checkRendering(rendering, usage) {\n  if (rendering === undefined || typeof rendering !== 'function') {\n    throw new Error(usage);\n  }\n}\n\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\nfunction isReactElement(object) {\n  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nfunction deprecate(fn, message) {\n  var hasAlreadyPrint = false;\n\n  return function () {\n    if (!hasAlreadyPrint) {\n      hasAlreadyPrint = true;\n\n      // eslint-disable-next-line no-console\n      console.warn('[InstantSearch.js]: ' + message);\n    }\n\n    return fn.apply(undefined, arguments);\n  };\n}\n\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\nfunction parseAroundLatLngFromString(value) {\n  var pattern = value.match(latLngRegExp);\n\n  // Since the value provided is the one send with the query, the API should\n  // throw an error due to the wrong format. So throw an error should be safe..\n  if (!pattern) {\n    throw new Error('Invalid value for \"aroundLatLng\" parameter: \"' + value + '\"');\n  }\n\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n}",null]}